import type { DataModel, Entity, Field, Relation } from '@/shared/schemas';

// Generate C# type from field type
function getCSharpType(fieldType: string, isRequired: boolean): string {
  const typeMap: Record<string, string> = {
    string: 'string',
    int: 'int',
    long: 'long',
    decimal: 'decimal',
    double: 'double',
    float: 'float',
    bool: 'bool',
    DateTime: 'DateTime',
    DateOnly: 'DateOnly',
    TimeOnly: 'TimeOnly',
    Guid: 'Guid',
    'byte[]': 'byte[]',
    json: 'string', // JSON stored as string in C#
  };
  
  const csharpType = typeMap[fieldType] || 'object';
  
  // Add nullable marker for non-required value types
  if (!isRequired && !['string', 'byte[]'].includes(fieldType)) {
    return `${csharpType}?`;
  }
  
  return csharpType;
}

// Generate field attributes
function getFieldAttributes(field: Field): string[] {
  const attrs: string[] = [];
  
  if (field.constraints.isPrimaryKey) {
    attrs.push('[Key]');
  }
  
  if (field.constraints.isRequired && field.type === 'string') {
    attrs.push('[Required]');
  }
  
  if (field.constraints.maxLength) {
    attrs.push(`[MaxLength(${field.constraints.maxLength})]`);
  }
  
  if (field.constraints.isAutoGenerated && field.type === 'Guid') {
    attrs.push('[DatabaseGenerated(DatabaseGeneratedOption.Identity)]');
  }
  
  return attrs;
}

// Generate EF Core entity class
export function generateEntityCode(entity: Entity, relations: Relation[], allEntities: Entity[]): string {
  const lines: string[] = [];
  
  lines.push(`public class ${entity.name}`);
  lines.push('{');
  
  // Properties
  for (const field of entity.fields) {
    const attrs = getFieldAttributes(field);
    for (const attr of attrs) {
      lines.push(`    ${attr}`);
    }
    
    const csharpType = getCSharpType(field.type, field.constraints.isRequired);
    const nullableSuffix = field.type === 'string' && !field.constraints.isRequired ? '?' : '';
    lines.push(`    public ${csharpType}${nullableSuffix} ${field.name} { get; set; }`);
    lines.push('');
  }
  
  // Navigation properties for relations
  const entityRelations = relations.filter(
    (r) => r.sourceEntityId === entity.id || r.targetEntityId === entity.id
  );
  
  for (const relation of entityRelations) {
    const isSource = relation.sourceEntityId === entity.id;
    const otherEntityId = isSource ? relation.targetEntityId : relation.sourceEntityId;
    const otherEntity = allEntities.find((e) => e.id === otherEntityId);
    
    if (otherEntity) {
      if (relation.cardinality === 'one-to-many') {
        if (isSource) {
          // Source side has collection
          lines.push(`    public virtual ICollection<${otherEntity.name}> ${otherEntity.name}s { get; set; } = new List<${otherEntity.name}>();`);
        } else {
          // Target side has single reference
          lines.push(`    public Guid? ${otherEntity.name}Id { get; set; }`);
          lines.push(`    public virtual ${otherEntity.name}? ${otherEntity.name} { get; set; }`);
        }
      } else if (relation.cardinality === 'one-to-one') {
        lines.push(`    public virtual ${otherEntity.name}? ${otherEntity.name} { get; set; }`);
      } else if (relation.cardinality === 'many-to-many') {
        lines.push(`    public virtual ICollection<${otherEntity.name}> ${otherEntity.name}s { get; set; } = new List<${otherEntity.name}>();`);
      }
      lines.push('');
    }
  }
  
  lines.push('}');
  
  return lines.join('\n');
}

// Generate all entities code
export function generateEntitiesCode(model: DataModel): string {
  const header = `using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace ${model.name.replace(/\s+/g, '')}.Entities
{
`;
  
  const entities = model.entities
    .map((entity) => generateEntityCode(entity, model.relations, model.entities))
    .map((code) => code.split('\n').map((line) => `    ${line}`).join('\n'))
    .join('\n\n');
  
  const footer = '\n}';
  
  return header + entities + footer;
}

// Generate DTO classes
export function generateDtosCode(model: DataModel): string {
  const header = `using System;
using System.Collections.Generic;

namespace ${model.name.replace(/\s+/g, '')}.DTOs
{
`;
  
  const dtos = model.entities.map((entity) => {
    const lines: string[] = [];
    
    // Create DTO
    lines.push(`    public class Create${entity.name}Dto`);
    lines.push('    {');
    for (const field of entity.fields) {
      if (!field.constraints.isPrimaryKey && !field.constraints.isAutoGenerated) {
        const csharpType = getCSharpType(field.type, field.constraints.isRequired);
        lines.push(`        public ${csharpType} ${field.name} { get; set; }`);
      }
    }
    lines.push('    }');
    lines.push('');
    
    // Update DTO
    lines.push(`    public class Update${entity.name}Dto`);
    lines.push('    {');
    for (const field of entity.fields) {
      if (!field.constraints.isPrimaryKey) {
        const csharpType = getCSharpType(field.type, false); // All fields optional in update
        lines.push(`        public ${csharpType}? ${field.name} { get; set; }`);
      }
    }
    lines.push('    }');
    lines.push('');
    
    // Response DTO
    lines.push(`    public class ${entity.name}Dto`);
    lines.push('    {');
    for (const field of entity.fields) {
      const csharpType = getCSharpType(field.type, field.constraints.isRequired);
      lines.push(`        public ${csharpType} ${field.name} { get; set; }`);
    }
    lines.push('    }');
    
    return lines.join('\n');
  }).join('\n\n');
  
  const footer = '\n}';
  
  return header + dtos + footer;
}

// Generate Controller code
export function generateControllerCode(model: DataModel): string {
  if (model.entities.length === 0) {
    return '// No entities to generate controllers for';
  }
  
  const entity = model.entities[0]; // Generate for first entity as example
  const entityName = entity.name;
  const entityNameLower = entityName.toLowerCase();
  
  return `using Microsoft.AspNetCore.Mvc;
using ${model.name.replace(/\s+/g, '')}.DTOs;
using ${model.name.replace(/\s+/g, '')}.Services;

namespace ${model.name.replace(/\s+/g, '')}.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class ${entityName}sController : ControllerBase
    {
        private readonly I${entityName}Service _${entityNameLower}Service;

        public ${entityName}sController(I${entityName}Service ${entityNameLower}Service)
        {
            _${entityNameLower}Service = ${entityNameLower}Service;
        }

        [HttpGet]
        public async Task<ActionResult<IEnumerable<${entityName}Dto>>> GetAll()
        {
            var items = await _${entityNameLower}Service.GetAllAsync();
            return Ok(items);
        }

        [HttpGet("{id}")]
        public async Task<ActionResult<${entityName}Dto>> GetById(Guid id)
        {
            var item = await _${entityNameLower}Service.GetByIdAsync(id);
            if (item == null)
                return NotFound();
            return Ok(item);
        }

        [HttpPost]
        public async Task<ActionResult<${entityName}Dto>> Create(Create${entityName}Dto dto)
        {
            var item = await _${entityNameLower}Service.CreateAsync(dto);
            return CreatedAtAction(nameof(GetById), new { id = item.Id }, item);
        }

        [HttpPut("{id}")]
        public async Task<ActionResult<${entityName}Dto>> Update(Guid id, Update${entityName}Dto dto)
        {
            var item = await _${entityNameLower}Service.UpdateAsync(id, dto);
            if (item == null)
                return NotFound();
            return Ok(item);
        }

        [HttpDelete("{id}")]
        public async Task<ActionResult> Delete(Guid id)
        {
            var success = await _${entityNameLower}Service.DeleteAsync(id);
            if (!success)
                return NotFound();
            return NoContent();
        }
    }
}`;
}

// Generate Migration SQL
export function generateMigrationCode(model: DataModel): string {
  if (model.entities.length === 0) {
    return '-- No entities to generate migrations for';
  }
  
  const lines: string[] = [];
  lines.push('-- Migration Script');
  lines.push(`-- Generated for: ${model.name}`);
  lines.push(`-- Generated at: ${new Date().toISOString()}`);
  lines.push('');
  
  for (const entity of model.entities) {
    const tableName = entity.tableName || entity.name + 's';
    
    lines.push(`-- Create table: ${tableName}`);
    lines.push(`CREATE TABLE [${tableName}] (`);
    
    const columnDefs: string[] = [];
    
    for (const field of entity.fields) {
      const sqlType = getSqlType(field.type, field.constraints.maxLength);
      const nullable = field.constraints.isRequired ? 'NOT NULL' : 'NULL';
      const pk = field.constraints.isPrimaryKey ? ' PRIMARY KEY' : '';
      const defaultVal = field.constraints.isAutoGenerated && field.type === 'Guid' 
        ? ' DEFAULT NEWID()' 
        : '';
      
      columnDefs.push(`    [${field.name}] ${sqlType} ${nullable}${pk}${defaultVal}`);
    }
    
    lines.push(columnDefs.join(',\n'));
    lines.push(');');
    lines.push('');
  }
  
  // Generate foreign keys for relations
  for (const relation of model.relations) {
    const sourceEntity = model.entities.find((e) => e.id === relation.sourceEntityId);
    const targetEntity = model.entities.find((e) => e.id === relation.targetEntityId);
    
    if (sourceEntity && targetEntity && relation.cardinality === 'one-to-many') {
      const sourceTable = sourceEntity.tableName || sourceEntity.name + 's';
      const targetTable = targetEntity.tableName || targetEntity.name + 's';
      
      lines.push(`-- Add foreign key: ${targetEntity.name} -> ${sourceEntity.name}`);
      lines.push(`ALTER TABLE [${targetTable}]`);
      lines.push(`ADD CONSTRAINT [FK_${targetTable}_${sourceTable}]`);
      lines.push(`FOREIGN KEY ([${sourceEntity.name}Id]) REFERENCES [${sourceTable}]([Id])`);
      lines.push(`ON DELETE ${relation.onDelete.toUpperCase().replace('NOACTION', 'NO ACTION')};`);
      lines.push('');
    }
  }
  
  return lines.join('\n');
}

function getSqlType(fieldType: string, maxLength?: number): string {
  const typeMap: Record<string, string> = {
    string: maxLength ? `NVARCHAR(${maxLength})` : 'NVARCHAR(MAX)',
    int: 'INT',
    long: 'BIGINT',
    decimal: 'DECIMAL(18,2)',
    double: 'FLOAT',
    float: 'REAL',
    bool: 'BIT',
    DateTime: 'DATETIME2',
    DateOnly: 'DATE',
    TimeOnly: 'TIME',
    Guid: 'UNIQUEIDENTIFIER',
    'byte[]': 'VARBINARY(MAX)',
    json: 'NVARCHAR(MAX)',
  };
  
  return typeMap[fieldType] || 'NVARCHAR(MAX)';
}

// Generate Swagger/OpenAPI spec
export function generateSwaggerCode(model: DataModel): string {
  const paths: Record<string, unknown> = {};
  const schemas: Record<string, unknown> = {};
  
  for (const entity of model.entities) {
    const entityName = entity.name;
    const pathName = `/${entityName.toLowerCase()}s`;
    
    // Generate schema
    const properties: Record<string, unknown> = {};
    const required: string[] = [];
    
    for (const field of entity.fields) {
      properties[field.name] = {
        type: getOpenApiType(field.type),
        format: getOpenApiFormat(field.type),
      };
      
      if (field.constraints.isRequired) {
        required.push(field.name);
      }
    }
    
    schemas[entityName] = {
      type: 'object',
      properties,
      required: required.length > 0 ? required : undefined,
    };
    
    // Generate paths
    paths[pathName] = {
      get: {
        summary: `Get all ${entityName}s`,
        responses: {
          '200': {
            description: 'Success',
            content: {
              'application/json': {
                schema: {
                  type: 'array',
                  items: { $ref: `#/components/schemas/${entityName}` },
                },
              },
            },
          },
        },
      },
      post: {
        summary: `Create a new ${entityName}`,
        requestBody: {
          content: {
            'application/json': {
              schema: { $ref: `#/components/schemas/${entityName}` },
            },
          },
        },
        responses: {
          '201': { description: 'Created' },
        },
      },
    };
    
    paths[`${pathName}/{id}`] = {
      get: {
        summary: `Get ${entityName} by ID`,
        parameters: [
          { name: 'id', in: 'path', required: true, schema: { type: 'string', format: 'uuid' } },
        ],
        responses: {
          '200': {
            description: 'Success',
            content: {
              'application/json': {
                schema: { $ref: `#/components/schemas/${entityName}` },
              },
            },
          },
          '404': { description: 'Not found' },
        },
      },
      put: {
        summary: `Update ${entityName}`,
        parameters: [
          { name: 'id', in: 'path', required: true, schema: { type: 'string', format: 'uuid' } },
        ],
        responses: {
          '200': { description: 'Success' },
          '404': { description: 'Not found' },
        },
      },
      delete: {
        summary: `Delete ${entityName}`,
        parameters: [
          { name: 'id', in: 'path', required: true, schema: { type: 'string', format: 'uuid' } },
        ],
        responses: {
          '204': { description: 'No content' },
          '404': { description: 'Not found' },
        },
      },
    };
  }
  
  const spec = {
    openapi: '3.0.0',
    info: {
      title: model.name,
      version: '1.0.0',
      description: model.description || `API for ${model.name}`,
    },
    paths,
    components: {
      schemas,
    },
  };
  
  // Convert to YAML-like format (simplified)
  return formatAsYaml(spec);
}

function getOpenApiType(fieldType: string): string {
  const typeMap: Record<string, string> = {
    string: 'string',
    int: 'integer',
    long: 'integer',
    decimal: 'number',
    double: 'number',
    float: 'number',
    bool: 'boolean',
    DateTime: 'string',
    DateOnly: 'string',
    TimeOnly: 'string',
    Guid: 'string',
    'byte[]': 'string',
    json: 'object',
  };
  return typeMap[fieldType] || 'string';
}

function getOpenApiFormat(fieldType: string): string | undefined {
  const formatMap: Record<string, string> = {
    int: 'int32',
    long: 'int64',
    decimal: 'double',
    double: 'double',
    float: 'float',
    DateTime: 'date-time',
    DateOnly: 'date',
    TimeOnly: 'time',
    Guid: 'uuid',
    'byte[]': 'byte',
  };
  return formatMap[fieldType];
}

function formatAsYaml(obj: unknown, indent = 0): string {
  const spaces = '  '.repeat(indent);
  
  if (obj === null || obj === undefined) {
    return 'null';
  }
  
  if (typeof obj === 'string') {
    return obj.includes(':') || obj.includes('#') ? `"${obj}"` : obj;
  }
  
  if (typeof obj === 'number' || typeof obj === 'boolean') {
    return String(obj);
  }
  
  if (Array.isArray(obj)) {
    if (obj.length === 0) return '[]';
    return obj.map((item) => `${spaces}- ${formatAsYaml(item, indent + 1).trimStart()}`).join('\n');
  }
  
  if (typeof obj === 'object') {
    const entries = Object.entries(obj).filter(([, v]) => v !== undefined);
    if (entries.length === 0) return '{}';
    
    return entries
      .map(([key, value]) => {
        const formattedValue = formatAsYaml(value, indent + 1);
        if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
          return `${spaces}${key}:\n${formattedValue}`;
        }
        if (Array.isArray(value)) {
          return `${spaces}${key}:\n${formattedValue}`;
        }
        return `${spaces}${key}: ${formattedValue}`;
      })
      .join('\n');
  }
  
  return String(obj);
}
