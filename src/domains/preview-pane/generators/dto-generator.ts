/**
 * DTO Generator
 * 
 * Generates Data Transfer Objects:
 * - CreateDto (for creating new entities)
 * - UpdateDto (for updating entities, all fields optional)
 * - ResponseDto (for API responses)
 */

import type { DataModel, Entity, Relation } from '@/shared/schemas';
import {
  toPascalCase,
  getNamespace,
  getCSharpType,
  getEntityById,
  getEntityRelations,
  getForeignKeyName,
  getPrimaryKeyField,
  joinLines,
} from './helpers';

/**
 * Generate Create DTO for an entity
 */
function generateCreateDto(
  entity: Entity,
  relations: Relation[],
  allEntities: Entity[]
): string[] {
  const lines: string[] = [];
  const entityName = toPascalCase(entity.name);
  const { outgoing } = getEntityRelations(entity, relations);
  
  lines.push(`/// <summary>`);
  lines.push(`/// DTO for creating a new ${entityName}`);
  lines.push(`/// </summary>`);
  lines.push(`public class Create${entityName}Dto`);
  lines.push('{');
  
  // Fields (excluding auto-generated ones)
  for (const field of entity.fields) {
    // Skip auto-generated fields
    if (field.constraints.isAutoGenerated) continue;
    // Skip primary key if it's auto-generated
    if (field.constraints.isPrimaryKey && field.constraints.isAutoGenerated) continue;
    
    const csharpType = getCSharpType(field);
    const fieldName = toPascalCase(field.name);
    
    // Add validation attributes
    if (field.constraints.isRequired) {
      lines.push('    [Required]');
    }
    if (field.type === 'string' && field.constraints.maxLength) {
      lines.push(`    [MaxLength(${field.constraints.maxLength})]`);
    }
    if (field.constraints.regex) {
      lines.push(`    [RegularExpression(@"${field.constraints.regex.replace(/\\/g, '\\\\')}")]`);
    }
    
    lines.push(`    public ${csharpType} ${fieldName} { get; set; }`);
    lines.push('');
  }
  
  // Foreign key properties for relationships
  for (const rel of outgoing) {
    const targetEntity = getEntityById({ entities: allEntities } as DataModel, rel.targetEntityId);
    if (!targetEntity) continue;
    
    if (rel.cardinality !== 'many-to-many') {
      const fkName = getForeignKeyName(targetEntity);
      const pkField = getPrimaryKeyField(targetEntity);
      const fkType = pkField ? getCSharpType({ ...pkField, constraints: { ...pkField.constraints, isRequired: false } }) : 'Guid?';
      
      // Check if FK already exists in fields
      const existingFk = entity.fields.find(f => 
        toPascalCase(f.name) === fkName || f.name === fkName
      );
      
      if (!existingFk) {
        lines.push(`    public ${fkType} ${fkName} { get; set; }`);
        lines.push('');
      }
    }
  }
  
  lines.push('}');
  
  return lines;
}

/**
 * Generate Update DTO for an entity (all fields optional)
 */
function generateUpdateDto(
  entity: Entity,
  relations: Relation[],
  allEntities: Entity[]
): string[] {
  const lines: string[] = [];
  const entityName = toPascalCase(entity.name);
  const { outgoing } = getEntityRelations(entity, relations);
  
  lines.push(`/// <summary>`);
  lines.push(`/// DTO for updating an existing ${entityName}`);
  lines.push(`/// </summary>`);
  lines.push(`public class Update${entityName}Dto`);
  lines.push('{');
  
  // Fields (excluding PK and auto-generated)
  for (const field of entity.fields) {
    // Skip primary key
    if (field.constraints.isPrimaryKey) continue;
    // Skip auto-generated fields
    if (field.constraints.isAutoGenerated) continue;
    
    // Make all fields optional for update
    const baseType = getCSharpType({ ...field, constraints: { ...field.constraints, isRequired: false } });
    const csharpType = baseType.endsWith('?') ? baseType : `${baseType}?`;
    const fieldName = toPascalCase(field.name);
    
    // Add validation attributes (optional validation)
    if (field.type === 'string' && field.constraints.maxLength) {
      lines.push(`    [MaxLength(${field.constraints.maxLength})]`);
    }
    
    lines.push(`    public ${csharpType} ${fieldName} { get; set; }`);
    lines.push('');
  }
  
  // Foreign key properties
  for (const rel of outgoing) {
    const targetEntity = getEntityById({ entities: allEntities } as DataModel, rel.targetEntityId);
    if (!targetEntity) continue;
    
    if (rel.cardinality !== 'many-to-many') {
      const fkName = getForeignKeyName(targetEntity);
      const pkField = getPrimaryKeyField(targetEntity);
      const fkType = pkField ? getCSharpType({ ...pkField, constraints: { ...pkField.constraints, isRequired: false } }) : 'Guid?';
      
      const existingFk = entity.fields.find(f => 
        toPascalCase(f.name) === fkName || f.name === fkName
      );
      
      if (!existingFk) {
        lines.push(`    public ${fkType} ${fkName} { get; set; }`);
        lines.push('');
      }
    }
  }
  
  lines.push('}');
  
  return lines;
}

/**
 * Generate Response DTO for an entity
 */
function generateResponseDto(
  entity: Entity,
  relations: Relation[],
  allEntities: Entity[]
): string[] {
  const lines: string[] = [];
  const entityName = toPascalCase(entity.name);
  const { outgoing } = getEntityRelations(entity, relations);
  
  lines.push(`/// <summary>`);
  lines.push(`/// DTO for ${entityName} API responses`);
  lines.push(`/// </summary>`);
  lines.push(`public class ${entityName}ResponseDto`);
  lines.push('{');
  
  // All fields
  for (const field of entity.fields) {
    const csharpType = getCSharpType(field);
    const fieldName = toPascalCase(field.name);
    lines.push(`    public ${csharpType} ${fieldName} { get; set; }`);
    lines.push('');
  }
  
  // Foreign key IDs
  for (const rel of outgoing) {
    const targetEntity = getEntityById({ entities: allEntities } as DataModel, rel.targetEntityId);
    if (!targetEntity) continue;
    
    const targetName = toPascalCase(targetEntity.name);
    
    if (rel.cardinality === 'many-to-many') {
      lines.push(`    public List<Guid> ${targetName}Ids { get; set; } = new();`);
    } else {
      const fkName = getForeignKeyName(targetEntity);
      const pkField = getPrimaryKeyField(targetEntity);
      const fkType = pkField ? getCSharpType({ ...pkField, constraints: { ...pkField.constraints, isRequired: false } }) : 'Guid?';
      
      const existingFk = entity.fields.find(f => 
        toPascalCase(f.name) === fkName || f.name === fkName
      );
      
      if (!existingFk) {
        lines.push(`    public ${fkType} ${fkName} { get; set; }`);
      }
    }
    lines.push('');
  }
  
  lines.push('}');
  
  return lines;
}

/**
 * Generate all DTOs for all entities
 */
export function generateDTOs(model: DataModel): string {
  const namespace = getNamespace(model.name);
  
  const lines: string[] = [];
  
  // Using statements
  lines.push('using System;');
  lines.push('using System.Collections.Generic;');
  lines.push('using System.ComponentModel.DataAnnotations;');
  lines.push('');
  lines.push(`namespace ${namespace}.DTOs;`);
  lines.push('');
  
  // Generate DTOs for each entity
  for (let i = 0; i < model.entities.length; i++) {
    const entity = model.entities[i];
    
    // Create DTO
    const createDto = generateCreateDto(entity, model.relations, model.entities);
    lines.push(...createDto);
    lines.push('');
    
    // Update DTO
    const updateDto = generateUpdateDto(entity, model.relations, model.entities);
    lines.push(...updateDto);
    lines.push('');
    
    // Response DTO
    const responseDto = generateResponseDto(entity, model.relations, model.entities);
    lines.push(...responseDto);
    
    if (i < model.entities.length - 1) {
      lines.push('');
    }
  }
  
  return joinLines(lines);
}
