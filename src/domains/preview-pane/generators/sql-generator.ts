/**
 * SQL Generator
 * 
 * Generates SQL DDL for multiple database systems:
 * - SQL Server
 * - PostgreSQL
 * - MySQL
 * - SQLite
 * 
 * Features:
 * - CREATE TABLE with all column definitions
 * - Primary keys
 * - Foreign keys with cascade rules
 * - Indexes (unique and non-unique)
 * - Default values
 * - CHECK constraints where supported
 */

import type { DataModel, Entity, Field, Index } from '@/shared/schemas';
import {
  toPascalCase,
  getTableName,
  getSqlType,
  getPrimaryKeyField,
  getEntityById,
  quoteIdentifier,
  getForeignKeyName,
  joinLines,
} from './helpers';
import type { DatabaseType } from './types';

interface SqlGeneratorOptions {
  databaseType: DatabaseType;
  schemaName?: string;
  includeDropStatements?: boolean;
}

/**
 * Get the full table name with schema
 */
function getFullTableName(tableName: string, options: SqlGeneratorOptions): string {
  const { databaseType, schemaName } = options;
  const quotedName = quoteIdentifier(tableName, databaseType);
  
  if (schemaName && databaseType !== 'sqlite' && databaseType !== 'mysql') {
    return `${quoteIdentifier(schemaName, databaseType)}.${quotedName}`;
  }
  
  return quotedName;
}

/**
 * Generate column definition SQL
 */
function generateColumnSql(
  field: Field,
  options: SqlGeneratorOptions,
  isPrimaryKey: boolean = false
): string {
  const { databaseType } = options;
  const columnName = quoteIdentifier(toPascalCase(field.name), databaseType);
  const sqlType = getSqlType(field, databaseType);
  
  let sql = `${columnName} ${sqlType}`;
  
  // NOT NULL / NULL
  if (isPrimaryKey || field.constraints.isRequired) {
    sql += ' NOT NULL';
  } else {
    sql += ' NULL';
  }
  
  // Auto-increment for primary key
  if (isPrimaryKey && field.constraints.isAutoGenerated && field.type === 'int') {
    switch (databaseType) {
      case 'sqlserver':
        sql += ' IDENTITY(1,1)';
        break;
      case 'postgresql':
        // Use SERIAL type instead - already handled in getSqlType
        break;
      case 'mysql':
        sql += ' AUTO_INCREMENT';
        break;
      case 'sqlite':
        // AUTOINCREMENT is implicit with INTEGER PRIMARY KEY
        break;
    }
  }
  
  // Default value
  if (field.constraints.defaultValue !== undefined && field.constraints.defaultValue !== null && field.constraints.defaultValue !== '') {
    const defaultExpr = getSqlDefaultValue(field, databaseType);
    if (defaultExpr) {
      sql += ` DEFAULT ${defaultExpr}`;
    }
  }
  
  return sql;
}

/**
 * Get SQL default value expression
 */
function getSqlDefaultValue(field: Field, databaseType: DatabaseType): string | null {
  const value = field.constraints.defaultValue;
  if (value === undefined || value === null || value === '') return null;
  
  switch (field.type) {
    case 'string':
      return `'${String(value).replace(/'/g, "''")}'`;
    case 'bool':
      if (databaseType === 'postgresql') {
        return value === 'true' ? 'TRUE' : 'FALSE';
      }
      return value === 'true' ? '1' : '0';
    case 'int':
    case 'long':
    case 'decimal':
    case 'double':
    case 'float':
      return String(value);
    case 'DateTime':
      if (value === 'now' || value === 'GETDATE()' || value === 'CURRENT_TIMESTAMP') {
        switch (databaseType) {
          case 'sqlserver': return 'GETDATE()';
          case 'postgresql': return 'NOW()';
          case 'mysql': return 'CURRENT_TIMESTAMP';
          case 'sqlite': return "datetime('now')";
        }
      }
      return `'${value}'`;
    case 'Guid':
      if (value === 'newguid' || value === 'NEWID()') {
        switch (databaseType) {
          case 'sqlserver': return 'NEWID()';
          case 'postgresql': return 'gen_random_uuid()';
          case 'mysql': return '(UUID())';
          case 'sqlite': return "(lower(hex(randomblob(4))) || '-' || lower(hex(randomblob(2))) || '-4' || substr(lower(hex(randomblob(2))),2) || '-' || substr('89ab',abs(random()) % 4 + 1, 1) || substr(lower(hex(randomblob(2))),2) || '-' || lower(hex(randomblob(6))))";
        }
      }
      return `'${value}'`;
    default:
      return null;
  }
}

/**
 * Generate DROP TABLE statement
 */
function generateDropTable(tableName: string, options: SqlGeneratorOptions): string {
  const fullTableName = getFullTableName(tableName, options);
  const { databaseType } = options;
  
  switch (databaseType) {
    case 'sqlserver':
      return `IF OBJECT_ID('${tableName}', 'U') IS NOT NULL DROP TABLE ${fullTableName};`;
    case 'postgresql':
    case 'mysql':
    case 'sqlite':
      return `DROP TABLE IF EXISTS ${fullTableName};`;
  }
}

/**
 * Generate CREATE TABLE statement for an entity
 */
function generateCreateTable(
  entity: Entity,
  model: DataModel,
  options: SqlGeneratorOptions
): string[] {
  const { databaseType } = options;
  const tableName = getTableName(entity);
  const fullTableName = getFullTableName(tableName, options);
  const pkField = getPrimaryKeyField(entity);
  
  const lines: string[] = [];
  
  lines.push(`CREATE TABLE ${fullTableName} (`);
  
  const columns: string[] = [];
  
  // Add all fields as columns
  for (const field of entity.fields) {
    const isPk = pkField && field.id === pkField.id;
    columns.push(`    ${generateColumnSql(field, options, isPk)}`);
  }
  
  // Add FK columns for relations where this entity is the "source" side (has the FK)
  const relationsFrom = model.relations.filter(r => r.sourceEntityId === entity.id);
  for (const relation of relationsFrom) {
    // Only add FK column for one-to-many (source is the "many" side) or one-to-one
    if (relation.cardinality === 'one-to-many' || relation.cardinality === 'one-to-one') {
      const targetEntity = getEntityById(model, relation.targetEntityId);
      if (targetEntity) {
        const targetPk = getPrimaryKeyField(targetEntity);
        if (targetPk) {
          const fkColumnName = getForeignKeyName(targetEntity);
          const fkSqlType = getSqlType(targetPk, databaseType);
          // Check if FK column already exists
          const fkExists = entity.fields.some(f => toPascalCase(f.name) === fkColumnName);
          if (!fkExists) {
            columns.push(`    ${quoteIdentifier(fkColumnName, databaseType)} ${fkSqlType} NULL`);
          }
        }
      }
    }
  }
  
  // Primary key constraint
  if (pkField) {
    const pkColumnName = quoteIdentifier(toPascalCase(pkField.name), databaseType);
    columns.push(`    CONSTRAINT ${quoteIdentifier(`PK_${tableName}`, databaseType)} PRIMARY KEY (${pkColumnName})`);
  }
  
  lines.push(columns.join(',\n'));
  lines.push(');');
  
  return lines;
}

/**
 * Generate foreign key constraints
 */
function generateForeignKeys(
  entity: Entity,
  model: DataModel,
  options: SqlGeneratorOptions
): string[] {
  const { databaseType } = options;
  const tableName = getTableName(entity);
  const fullTableName = getFullTableName(tableName, options);
  
  const lines: string[] = [];
  
  const relationsFrom = model.relations.filter(r => r.sourceEntityId === entity.id);
  
  for (const relation of relationsFrom) {
    if (relation.cardinality === 'one-to-many' || relation.cardinality === 'one-to-one') {
      const targetEntity = getEntityById(model, relation.targetEntityId);
      if (targetEntity) {
        const targetTableName = getTableName(targetEntity);
        const targetFullTableName = getFullTableName(targetTableName, options);
        const targetPk = getPrimaryKeyField(targetEntity);
        
        if (targetPk) {
          const fkColumnName = getForeignKeyName(targetEntity);
          const fkConstraintName = `FK_${tableName}_${targetTableName}_${fkColumnName}`;
          const targetPkColumnName = toPascalCase(targetPk.name);
          
          // Delete behavior - map from schema format
          const onDelete = relation.onDelete || 'noAction';
          let onDeleteAction = 'NO ACTION';
          
          switch (onDelete) {
            case 'cascade': onDeleteAction = 'CASCADE'; break;
            case 'setNull': onDeleteAction = 'SET NULL'; break;
            case 'restrict': onDeleteAction = databaseType === 'mysql' ? 'RESTRICT' : 'NO ACTION'; break;
            case 'noAction':
            default:
              onDeleteAction = databaseType === 'mysql' ? 'RESTRICT' : 'NO ACTION';
          }
          
          lines.push(`ALTER TABLE ${fullTableName}`);
          lines.push(`    ADD CONSTRAINT ${quoteIdentifier(fkConstraintName, databaseType)}`);
          lines.push(`    FOREIGN KEY (${quoteIdentifier(fkColumnName, databaseType)})`);
          lines.push(`    REFERENCES ${targetFullTableName} (${quoteIdentifier(targetPkColumnName, databaseType)})`);
          lines.push(`    ON DELETE ${onDeleteAction};`);
          lines.push('');
        }
      }
    }
  }
  
  return lines;
}

/**
 * Generate index statements for an entity
 */
function generateIndexes(
  entity: Entity,
  indexes: Index[],
  options: SqlGeneratorOptions
): string[] {
  const { databaseType } = options;
  const tableName = getTableName(entity);
  const fullTableName = getFullTableName(tableName, options);
  
  const lines: string[] = [];
  
  // Filter indexes for this entity
  const entityIndexes = indexes.filter(idx => idx.entityId === entity.id);
  
  if (entityIndexes.length === 0) {
    return lines;
  }
  
  for (const index of entityIndexes) {
    const indexName = index.name || `IX_${tableName}_${index.fieldIds.join('_')}`;
    const indexColumns = index.fieldIds
      .map(fieldId => {
        const field = entity.fields.find(f => f.id === fieldId);
        return field ? quoteIdentifier(toPascalCase(field.name), databaseType) : null;
      })
      .filter(Boolean)
      .join(', ');
    
    if (!indexColumns) continue;
    
    const uniqueKeyword = index.isUnique ? 'UNIQUE ' : '';
    
    lines.push(`CREATE ${uniqueKeyword}INDEX ${quoteIdentifier(indexName, databaseType)}`);
    lines.push(`    ON ${fullTableName} (${indexColumns});`);
    lines.push('');
  }
  
  return lines;
}

/**
 * Generate complete SQL DDL for a data model
 */
export function generateSQL(
  model: DataModel,
  options: Partial<SqlGeneratorOptions> = {}
): string {
  const fullOptions: SqlGeneratorOptions = {
    databaseType: options.databaseType || 'sqlserver',
    schemaName: options.schemaName,
    includeDropStatements: options.includeDropStatements ?? false,
  };
  
  if (model.entities.length === 0) {
    return '-- No entities to generate SQL for';
  }
  
  const { databaseType, includeDropStatements } = fullOptions;
  
  const lines: string[] = [];
  
  // Header
  lines.push(`-- ===========================================`);
  lines.push(`-- SQL DDL for ${model.name}`);
  lines.push(`-- Database: ${databaseType.toUpperCase()}`);
  lines.push(`-- Generated at: ${new Date().toISOString()}`);
  lines.push(`-- ===========================================`);
  lines.push('');
  
  // Drop statements (in reverse order for FK dependencies)
  if (includeDropStatements) {
    lines.push('-- Drop existing tables');
    const reversedEntities = [...model.entities].reverse();
    for (const entity of reversedEntities) {
      const tableName = getTableName(entity);
      lines.push(generateDropTable(tableName, fullOptions));
    }
    lines.push('');
  }
  
  // Create tables
  lines.push('-- ===========================================');
  lines.push('-- Create Tables');
  lines.push('-- ===========================================');
  lines.push('');
  
  for (const entity of model.entities) {
    const createTableLines = generateCreateTable(entity, model, fullOptions);
    lines.push(...createTableLines);
    lines.push('');
  }
  
  // Foreign keys
  const hasForeignKeys = model.relations.some(r => 
    r.cardinality === 'one-to-many' || r.cardinality === 'one-to-one'
  );
  
  if (hasForeignKeys) {
    lines.push('-- ===========================================');
    lines.push('-- Foreign Key Constraints');
    lines.push('-- ===========================================');
    lines.push('');
    
    for (const entity of model.entities) {
      const fkLines = generateForeignKeys(entity, model, fullOptions);
      if (fkLines.length > 0) {
        lines.push(...fkLines);
      }
    }
  }
  
  // Indexes
  const hasIndexes = model.indexes && model.indexes.length > 0;
  
  if (hasIndexes) {
    lines.push('-- ===========================================');
    lines.push('-- Indexes');
    lines.push('-- ===========================================');
    lines.push('');
    
    for (const entity of model.entities) {
      const indexLines = generateIndexes(entity, model.indexes, fullOptions);
      if (indexLines.length > 0) {
        lines.push(...indexLines);
      }
    }
  }
  
  return joinLines(lines);
}

/**
 * Generate SQL Server specific SQL
 */
export function generateSqlServerSQL(model: DataModel, includeDropStatements = false): string {
  return generateSQL(model, { databaseType: 'sqlserver', includeDropStatements });
}

/**
 * Generate PostgreSQL specific SQL
 */
export function generatePostgresSQL(model: DataModel, includeDropStatements = false): string {
  return generateSQL(model, { databaseType: 'postgresql', includeDropStatements });
}

/**
 * Generate MySQL specific SQL
 */
export function generateMySQLSQL(model: DataModel, includeDropStatements = false): string {
  return generateSQL(model, { databaseType: 'mysql', includeDropStatements });
}

/**
 * Generate SQLite specific SQL
 */
export function generateSQLiteSQL(model: DataModel, includeDropStatements = false): string {
  return generateSQL(model, { databaseType: 'sqlite', includeDropStatements });
}
