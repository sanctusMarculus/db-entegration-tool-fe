import { create } from 'zustand';
import { immer } from 'zustand/middleware/immer';
import { persist } from 'zustand/middleware';
import { useShallow } from 'zustand/shallow';
import { v4 as uuidv4 } from 'uuid';
import type {
  DataModel,
  Entity,
  Field,
  Relation,
  Index,
  Position,
  EntityColor,
  FieldType,
  Cardinality,
} from '@/shared/schemas';

interface ModelState {
  // Current model data
  model: DataModel | null;
  
  // Selection state
  selectedEntityId: string | null;
  selectedFieldId: string | null;
  selectedRelationId: string | null;
  
  // UI state
  isLoading: boolean;
  isDirty: boolean;
  
  // Actions
  setModel: (model: DataModel | null) => void;
  createNewModel: (name: string, description?: string) => void;
  updateModelMeta: (name: string, description?: string) => void;
  
  // Entity actions
  addEntity: (name: string, position: Position, color?: EntityColor) => string;
  updateEntity: (entityId: string, updates: Partial<Omit<Entity, 'id' | 'fields'>>) => void;
  deleteEntity: (entityId: string) => void;
  duplicateEntity: (entityId: string) => string | null;
  
  // Field actions
  addField: (entityId: string, name: string, type: FieldType) => string | null;
  updateField: (entityId: string, fieldId: string, updates: Partial<Omit<Field, 'id'>>) => void;
  deleteField: (entityId: string, fieldId: string) => void;
  reorderFields: (entityId: string, fromIndex: number, toIndex: number) => void;
  
  // Relation actions
  addRelation: (
    sourceEntityId: string,
    targetEntityId: string,
    cardinality: Cardinality,
    name?: string
  ) => string;
  updateRelation: (relationId: string, updates: Partial<Omit<Relation, 'id'>>) => void;
  deleteRelation: (relationId: string) => void;
  
  // Index actions
  addIndex: (entityId: string, fieldIds: string[], name?: string, isUnique?: boolean) => string | null;
  updateIndex: (indexId: string, updates: Partial<Omit<Index, 'id'>>) => void;
  deleteIndex: (indexId: string) => void;
  
  // Selection actions
  selectEntity: (entityId: string | null) => void;
  selectField: (fieldId: string | null) => void;
  selectRelation: (relationId: string | null) => void;
  clearSelection: () => void;
  
  // Canvas actions
  updateEntityPosition: (entityId: string, position: Position) => void;
  
  // Utility
  markClean: () => void;
  getEntityById: (entityId: string) => Entity | undefined;
  getFieldById: (entityId: string, fieldId: string) => Field | undefined;
  getRelationById: (relationId: string) => Relation | undefined;
}

export const useModelStore = create<ModelState>()(
  persist(
    immer((set, get) => ({
      model: null,
      selectedEntityId: null,
      selectedFieldId: null,
      selectedRelationId: null,
      isLoading: false,
      isDirty: false,
      
      setModel: (model) =>
        set((state) => {
          state.model = model;
          state.isDirty = false;
          state.selectedEntityId = null;
          state.selectedFieldId = null;
          state.selectedRelationId = null;
        }),
      
      createNewModel: (name, description) =>
        set((state) => {
          const now = new Date().toISOString();
          state.model = {
            id: uuidv4(),
            name,
            description,
            entities: [],
            relations: [],
            indexes: [],
            createdAt: now,
            updatedAt: now,
            version: 1,
          };
          state.isDirty = true;
        }),
      
      updateModelMeta: (name, description) =>
        set((state) => {
          if (state.model) {
            state.model.name = name;
            state.model.description = description;
            state.model.updatedAt = new Date().toISOString();
            state.isDirty = true;
          }
        }),
      
      addEntity: (name, position, color = 'blue') => {
        const entityId = uuidv4();
        const pkFieldId = uuidv4();
        
        set((state) => {
          if (state.model) {
            const newEntity: Entity = {
              id: entityId,
              name,
              position,
              color,
              fields: [
                {
                  id: pkFieldId,
                  name: 'Id',
                  type: 'Guid',
                  constraints: {
                    isPrimaryKey: true,
                    isRequired: true,
                    isAutoGenerated: true,
                    isUnique: false,
                  },
                  annotations: [],
                },
              ],
              isAbstract: false,
            };
            state.model.entities.push(newEntity);
            state.model.updatedAt = new Date().toISOString();
            state.isDirty = true;
            state.selectedEntityId = entityId;
          }
        });
        
        return entityId;
      },
      
      updateEntity: (entityId, updates) =>
        set((state) => {
          if (state.model) {
            const entity = state.model.entities.find((e) => e.id === entityId);
            if (entity) {
              Object.assign(entity, updates);
              state.model.updatedAt = new Date().toISOString();
              state.isDirty = true;
            }
          }
        }),
      
      deleteEntity: (entityId) =>
        set((state) => {
          if (state.model) {
            state.model.entities = state.model.entities.filter((e) => e.id !== entityId);
            state.model.relations = state.model.relations.filter(
              (r) => r.sourceEntityId !== entityId && r.targetEntityId !== entityId
            );
            state.model.indexes = state.model.indexes.filter((i) => i.entityId !== entityId);
            state.model.updatedAt = new Date().toISOString();
            state.isDirty = true;
            if (state.selectedEntityId === entityId) {
              state.selectedEntityId = null;
              state.selectedFieldId = null;
            }
          }
        }),
      
      duplicateEntity: (entityId) => {
        const { model } = get();
        if (!model) return null;
        
        const entity = model.entities.find((e) => e.id === entityId);
        if (!entity) return null;
        
        const newEntityId = uuidv4();
        
        set((state) => {
          if (state.model) {
            const newEntity: Entity = {
              ...JSON.parse(JSON.stringify(entity)),
              id: newEntityId,
              name: `${entity.name}_copy`,
              position: {
                x: entity.position.x + 50,
                y: entity.position.y + 50,
              },
              fields: entity.fields.map((f) => ({
                ...f,
                id: uuidv4(),
              })),
            };
            state.model.entities.push(newEntity);
            state.model.updatedAt = new Date().toISOString();
            state.isDirty = true;
            state.selectedEntityId = newEntityId;
          }
        });
        
        return newEntityId;
      },
      
      addField: (entityId, name, type) => {
        const fieldId = uuidv4();
        
        set((state) => {
          if (state.model) {
            const entity = state.model.entities.find((e) => e.id === entityId);
            if (entity) {
              const newField: Field = {
                id: fieldId,
                name,
                type,
                constraints: {
                  isRequired: false,
                  isUnique: false,
                  isPrimaryKey: false,
                  isAutoGenerated: false,
                },
                annotations: [],
              };
              entity.fields.push(newField);
              state.model.updatedAt = new Date().toISOString();
              state.isDirty = true;
              state.selectedFieldId = fieldId;
            }
          }
        });
        
        return fieldId;
      },
      
      updateField: (entityId, fieldId, updates) =>
        set((state) => {
          if (state.model) {
            const entity = state.model.entities.find((e) => e.id === entityId);
            if (entity) {
              const field = entity.fields.find((f) => f.id === fieldId);
              if (field) {
                Object.assign(field, updates);
                state.model.updatedAt = new Date().toISOString();
                state.isDirty = true;
              }
            }
          }
        }),
      
      deleteField: (entityId, fieldId) =>
        set((state) => {
          if (state.model) {
            const entity = state.model.entities.find((e) => e.id === entityId);
            if (entity) {
              entity.fields = entity.fields.filter((f) => f.id !== fieldId);
              state.model.updatedAt = new Date().toISOString();
              state.isDirty = true;
              if (state.selectedFieldId === fieldId) {
                state.selectedFieldId = null;
              }
            }
          }
        }),
      
      reorderFields: (entityId, fromIndex, toIndex) =>
        set((state) => {
          if (state.model) {
            const entity = state.model.entities.find((e) => e.id === entityId);
            if (entity) {
              const [field] = entity.fields.splice(fromIndex, 1);
              entity.fields.splice(toIndex, 0, field);
              state.model.updatedAt = new Date().toISOString();
              state.isDirty = true;
            }
          }
        }),
      
      addRelation: (sourceEntityId, targetEntityId, cardinality, name) => {
        const relationId = uuidv4();
        
        set((state) => {
          if (state.model) {
            const sourceEntity = state.model.entities.find((e) => e.id === sourceEntityId);
            const targetEntity = state.model.entities.find((e) => e.id === targetEntityId);
            
            if (sourceEntity && targetEntity) {
              const newRelation: Relation = {
                id: relationId,
                name: name || `${sourceEntity.name}_${targetEntity.name}`,
                sourceEntityId,
                targetEntityId,
                cardinality,
                onDelete: 'noAction',
                onUpdate: 'noAction',
              };
              state.model.relations.push(newRelation);
              state.model.updatedAt = new Date().toISOString();
              state.isDirty = true;
            }
          }
        });
        
        return relationId;
      },
      
      updateRelation: (relationId, updates) =>
        set((state) => {
          if (state.model) {
            const relation = state.model.relations.find((r) => r.id === relationId);
            if (relation) {
              Object.assign(relation, updates);
              state.model.updatedAt = new Date().toISOString();
              state.isDirty = true;
            }
          }
        }),
      
      deleteRelation: (relationId) =>
        set((state) => {
          if (state.model) {
            state.model.relations = state.model.relations.filter((r) => r.id !== relationId);
            state.model.updatedAt = new Date().toISOString();
            state.isDirty = true;
            if (state.selectedRelationId === relationId) {
              state.selectedRelationId = null;
            }
          }
        }),
      
      addIndex: (entityId, fieldIds, name, isUnique = false) => {
        const indexId = uuidv4();
        
        set((state) => {
          if (state.model) {
            const entity = state.model.entities.find((e) => e.id === entityId);
            if (entity) {
              const newIndex: Index = {
                id: indexId,
                name: name || `IX_${entity.name}_${fieldIds.length}`,
                entityId,
                fieldIds,
                isUnique,
                isClustered: false,
              };
              state.model.indexes.push(newIndex);
              state.model.updatedAt = new Date().toISOString();
              state.isDirty = true;
            }
          }
        });
        
        return indexId;
      },
      
      updateIndex: (indexId, updates) =>
        set((state) => {
          if (state.model) {
            const index = state.model.indexes.find((i) => i.id === indexId);
            if (index) {
              Object.assign(index, updates);
              state.model.updatedAt = new Date().toISOString();
              state.isDirty = true;
            }
          }
        }),
      
      deleteIndex: (indexId) =>
        set((state) => {
          if (state.model) {
            state.model.indexes = state.model.indexes.filter((i) => i.id !== indexId);
            state.model.updatedAt = new Date().toISOString();
            state.isDirty = true;
          }
        }),
      
      selectEntity: (entityId) =>
        set((state) => {
          state.selectedEntityId = entityId;
          state.selectedFieldId = null;
          state.selectedRelationId = null;
        }),
      
      selectField: (fieldId) =>
        set((state) => {
          state.selectedFieldId = fieldId;
          state.selectedRelationId = null;
        }),
      
      selectRelation: (relationId) =>
        set((state) => {
          state.selectedRelationId = relationId;
          state.selectedEntityId = null;
          state.selectedFieldId = null;
        }),
      
      clearSelection: () =>
        set((state) => {
          state.selectedEntityId = null;
          state.selectedFieldId = null;
          state.selectedRelationId = null;
        }),
      
      updateEntityPosition: (entityId, position) =>
        set((state) => {
          if (state.model) {
            const entity = state.model.entities.find((e) => e.id === entityId);
            if (entity) {
              entity.position = position;
              // Don't mark dirty for position changes to avoid excessive saves
            }
          }
        }),
      
      markClean: () =>
        set((state) => {
          state.isDirty = false;
        }),
      
      getEntityById: (entityId) => {
        const { model } = get();
        return model?.entities.find((e) => e.id === entityId);
      },
      
      getFieldById: (entityId, fieldId) => {
        const { model } = get();
        const entity = model?.entities.find((e) => e.id === entityId);
        return entity?.fields.find((f) => f.id === fieldId);
      },
      
      getRelationById: (relationId) => {
        const { model } = get();
        return model?.relations.find((r) => r.id === relationId);
      },
    })),
    {
      name: 'model-store',
      partialize: (state) => ({ model: state.model }),
    }
  )
);

// Selectors for optimized re-renders
export const useSelectedEntity = () =>
  useModelStore((state) => {
    if (!state.selectedEntityId || !state.model) return null;
    return state.model.entities.find((e) => e.id === state.selectedEntityId) ?? null;
  });

export const useSelectedField = () =>
  useModelStore((state) => {
    if (!state.selectedEntityId || !state.selectedFieldId || !state.model) return null;
    const entity = state.model.entities.find((e) => e.id === state.selectedEntityId);
    return entity?.fields.find((f) => f.id === state.selectedFieldId) ?? null;
  });

export const useSelectedRelation = () =>
  useModelStore((state) => {
    if (!state.selectedRelationId || !state.model) return null;
    return state.model.relations.find((r) => r.id === state.selectedRelationId) ?? null;
  });

// Use useShallow for array selectors to prevent infinite loops
export const useEntities = () =>
  useModelStore(useShallow((state) => state.model?.entities ?? []));

export const useRelations = () =>
  useModelStore(useShallow((state) => state.model?.relations ?? []));

export const useIndexes = () =>
  useModelStore(useShallow((state) => state.model?.indexes ?? []));
