/**
 * Data synchronization utilities between frontend and backend
 * 
 * The frontend uses a richer model format for the visual designer,
 * while the backend stores a simplified schema format.
 * 
 * This module handles the conversion between formats and provides
 * sync utilities for loading/saving data.
 */

import type { 
  DataModel, 
  Entity, 
  Field, 
  Relation, 
  Workspace 
} from '@/shared/schemas';
import type { 
  Schema, 
  SchemaJson, 
  EntityNode, 
  EntityField, 
  Relationship,
  UiMetadata,
  Project,
} from './api-client';

// ============================================================================
// Type Converters: Backend → Frontend
// ============================================================================

/**
 * Convert backend EntityField to frontend Field
 */
function backendFieldToFrontend(field: EntityField): Field {
  return {
    id: field.id,
    name: field.name,
    type: field.type as Field['type'],
    constraints: {
      isRequired: field.isRequired,
      isUnique: field.isUnique,
      isPrimaryKey: field.isPrimaryKey,
      isAutoGenerated: field.isPrimaryKey, // Assume PK is auto-generated
      maxLength: field.maxLength,
    },
    description: field.description,
    annotations: [],
  };
}

/**
 * Convert backend EntityNode to frontend Entity
 */
function backendEntityToFrontend(
  entity: EntityNode, 
  position: { x: number; y: number } = { x: 0, y: 0 }
): Entity {
  return {
    id: entity.id,
    name: entity.name,
    tableName: entity.tableName,
    fields: entity.fields.map(backendFieldToFrontend),
    position,
    color: 'blue', // Default, could be stored in uiMetadata
    description: entity.description,
    isAbstract: false,
  };
}

/**
 * Convert backend Relationship to frontend Relation
 */
function backendRelationToFrontend(rel: Relationship): Relation {
  return {
    id: rel.id,
    name: `${rel.sourceField}_${rel.targetField}`,
    sourceEntityId: rel.sourceEntityId,
    targetEntityId: rel.targetEntityId,
    cardinality: rel.type,
    sourceFieldId: rel.sourceField,
    targetFieldId: rel.targetField,
    onDelete: (rel.onDelete?.replace('-', '') as Relation['onDelete']) ?? 'noAction',
    onUpdate: 'noAction',
  };
}

/**
 * Convert backend Schema to frontend DataModel
 */
export function backendSchemaToDataModel(schema: Schema): DataModel {
  const schemaJson = schema.schemaJson as SchemaJson;
  const uiMetadata = schema.uiMetadata as UiMetadata | null;
  
  // Get positions from uiMetadata, or generate grid layout
  const positions = uiMetadata?.nodePositions ?? {};
  
  const entities = schemaJson.entities.map((entity, index) => {
    const pos = positions[entity.id] ?? { 
      x: (index % 4) * 300 + 50, 
      y: Math.floor(index / 4) * 250 + 50 
    };
    return backendEntityToFrontend(entity, pos);
  });
  
  const relations = schemaJson.relationships.map(backendRelationToFrontend);
  
  return {
    id: schema.id,
    name: schema.name,
    description: undefined,
    entities,
    relations,
    indexes: [],
    createdAt: schema.createdAt,
    updatedAt: schema.updatedAt,
    version: schema.currentVersion,
  };
}

// ============================================================================
// Type Converters: Frontend → Backend
// ============================================================================

/**
 * Convert frontend Field to backend EntityField
 */
function frontendFieldToBackend(field: Field): EntityField {
  return {
    id: field.id,
    name: field.name,
    type: field.type,
    isRequired: field.constraints.isRequired,
    isUnique: field.constraints.isUnique,
    isPrimaryKey: field.constraints.isPrimaryKey,
    defaultValue: field.constraints.defaultValue,
    maxLength: field.constraints.maxLength,
    description: field.description,
  };
}

/**
 * Convert frontend Entity to backend EntityNode
 */
function frontendEntityToBackend(entity: Entity): EntityNode {
  return {
    id: entity.id,
    name: entity.name,
    tableName: entity.tableName ?? entity.name,
    fields: entity.fields.map(frontendFieldToBackend),
    description: entity.description,
  };
}

/**
 * Convert frontend Relation to backend Relationship
 */
function frontendRelationToBackend(relation: Relation): Relationship {
  // Map frontend onDelete values to backend format
  const onDeleteMap: Record<string, Relationship['onDelete']> = {
    cascade: 'cascade',
    restrict: 'restrict',
    setNull: 'set-null',
    noAction: 'no-action',
  };
  
  return {
    id: relation.id,
    sourceEntityId: relation.sourceEntityId,
    targetEntityId: relation.targetEntityId,
    sourceField: relation.sourceFieldId ?? '',
    targetField: relation.targetFieldId ?? '',
    type: relation.cardinality,
    onDelete: onDeleteMap[relation.onDelete] ?? 'no-action',
  };
}

/**
 * Convert frontend DataModel to backend SchemaJson + UiMetadata
 */
export function dataModelToBackendSchema(model: DataModel): { 
  schemaJson: SchemaJson; 
  uiMetadata: UiMetadata;
} {
  const schemaJson: SchemaJson = {
    entities: model.entities.map(frontendEntityToBackend),
    relationships: model.relations.map(frontendRelationToBackend),
  };
  
  const uiMetadata: UiMetadata = {
    nodePositions: model.entities.reduce((acc, entity) => {
      acc[entity.id] = entity.position;
      return acc;
    }, {} as Record<string, { x: number; y: number }>),
  };
  
  return { schemaJson, uiMetadata };
}

// ============================================================================
// Workspace Sync Types
// ============================================================================

export interface SyncedWorkspace extends Omit<Workspace, 'models'> {
  backendProjectId: string;
  models: DataModel[];
}

/**
 * Convert backend Project + Schemas to frontend workspace format
 */
export function backendProjectToWorkspace(
  project: Project, 
  schemas: Schema[]
): SyncedWorkspace {
  const models = schemas.map(backendSchemaToDataModel);
  
  return {
    id: project.id, // Use backend ID as workspace ID for consistency
    backendProjectId: project.id,
    name: project.name,
    models,
    activeModelId: models[0]?.id,
    createdAt: project.createdAt,
    updatedAt: project.updatedAt,
  };
}
